{"ast":null,"code":"/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\nvar Ruler = require('./ruler');\nvar _rules = [\n// First 2 params - rule name & source. Secondary array - list of rules,\n// which can be terminated by this one.\n['table', require('./rules_block/table'), ['paragraph', 'reference']], ['code', require('./rules_block/code')], ['fence', require('./rules_block/fence'), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', require('./rules_block/blockquote'), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', require('./rules_block/hr'), ['paragraph', 'reference', 'blockquote', 'list']], ['list', require('./rules_block/list'), ['paragraph', 'reference', 'blockquote']], ['reference', require('./rules_block/reference')], ['html_block', require('./rules_block/html_block'), ['paragraph', 'reference', 'blockquote']], ['heading', require('./rules_block/heading'), ['paragraph', 'reference', 'blockquote']], ['lheading', require('./rules_block/lheading')], ['paragraph', require('./rules_block/paragraph')]];\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], {\n      alt: (_rules[i][2] || []).slice()\n    });\n  }\n}\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok,\n    i,\n    prevLine,\n    rules = this.ruler.getRules(''),\n    len = rules.length,\n    line = startLine,\n    hasEmptyLines = false,\n    maxNesting = state.md.options.maxNesting;\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) {\n      break;\n    }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) {\n      break;\n    }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n    prevLine = state.line;\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\");\n        }\n        break;\n      }\n    }\n\n    // this can only happen if user disables paragraph rule\n    if (!ok) throw new Error('none of the block rules matched');\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n    line = state.line;\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n  if (!src) {\n    return;\n  }\n  state = new this.State(src, md, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n};\nParserBlock.prototype.State = require('./rules_block/state_block');\nmodule.exports = ParserBlock;","map":{"version":3,"names":["Ruler","require","_rules","ParserBlock","ruler","i","length","push","alt","slice","prototype","tokenize","state","startLine","endLine","ok","prevLine","rules","getRules","len","line","hasEmptyLines","maxNesting","md","options","skipEmptyLines","sCount","blkIndent","level","Error","tight","isEmpty","parse","src","env","outTokens","State","lineMax","module","exports"],"sources":["/Users/wangbaiyuan/Documents/Wehelp/Part3/Vcard/client/node_modules/markdown-it/lib/parser_block.js"],"sourcesContent":["/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i, prevLine,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n    prevLine = state.line;\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\");\n        }\n        break;\n      }\n    }\n\n    // this can only happen if user disables paragraph rule\n    if (!ok) throw new Error('none of the block rules matched');\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}