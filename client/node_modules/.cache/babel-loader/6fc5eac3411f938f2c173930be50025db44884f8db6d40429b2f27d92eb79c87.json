{"ast":null,"code":"// Paragraph\n\n'use strict';\n\nmodule.exports = function paragraph(state, startLine, endLine) {\n  var content,\n    terminate,\n    i,\n    l,\n    token,\n    oldParentType,\n    nextLine = startLine + 1,\n    terminatorRules = state.md.block.ruler.getRules('paragraph');\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n  token = state.push('paragraph_open', 'p', 1);\n  token.map = [startLine, state.line];\n  token = state.push('inline', '', 0);\n  token.content = content;\n  token.map = [startLine, state.line];\n  token.children = [];\n  token = state.push('paragraph_close', 'p', -1);\n  state.parentType = oldParentType;\n  return true;\n};","map":{"version":3,"names":["module","exports","paragraph","state","startLine","endLine","content","terminate","i","l","token","oldParentType","nextLine","terminatorRules","md","block","ruler","getRules","parentType","isEmpty","sCount","blkIndent","length","getLines","trim","line","push","map","children"],"sources":["/Users/wangbaiyuan/Documents/Wehelp/Part3/Vcard/client/node_modules/markdown-it/lib/rules_block/paragraph.js"],"sourcesContent":["// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine, endLine) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n"],"mappings":"AAAA;;AAEA,YAAY;;AAGZA,MAAM,CAACC,OAAO,GAAG,SAASC,SAASA,CAACC,KAAK,EAAEC,SAAS,EAAEC,OAAO,EAAE;EAC7D,IAAIC,OAAO;IAAEC,SAAS;IAAEC,CAAC;IAAEC,CAAC;IAAEC,KAAK;IAAEC,aAAa;IAC9CC,QAAQ,GAAGR,SAAS,GAAG,CAAC;IACxBS,eAAe,GAAGV,KAAK,CAACW,EAAE,CAACC,KAAK,CAACC,KAAK,CAACC,QAAQ,CAAC,WAAW,CAAC;EAEhEN,aAAa,GAAGR,KAAK,CAACe,UAAU;EAChCf,KAAK,CAACe,UAAU,GAAG,WAAW;;EAE9B;EACA,OAAON,QAAQ,GAAGP,OAAO,IAAI,CAACF,KAAK,CAACgB,OAAO,CAACP,QAAQ,CAAC,EAAEA,QAAQ,EAAE,EAAE;IACjE;IACA;IACA,IAAIT,KAAK,CAACiB,MAAM,CAACR,QAAQ,CAAC,GAAGT,KAAK,CAACkB,SAAS,GAAG,CAAC,EAAE;MAAE;IAAU;;IAE9D;IACA,IAAIlB,KAAK,CAACiB,MAAM,CAACR,QAAQ,CAAC,GAAG,CAAC,EAAE;MAAE;IAAU;;IAE5C;IACAL,SAAS,GAAG,KAAK;IACjB,KAAKC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGI,eAAe,CAACS,MAAM,EAAEd,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAClD,IAAIK,eAAe,CAACL,CAAC,CAAC,CAACL,KAAK,EAAES,QAAQ,EAAEP,OAAO,EAAE,IAAI,CAAC,EAAE;QACtDE,SAAS,GAAG,IAAI;QAChB;MACF;IACF;IACA,IAAIA,SAAS,EAAE;MAAE;IAAO;EAC1B;EAEAD,OAAO,GAAGH,KAAK,CAACoB,QAAQ,CAACnB,SAAS,EAAEQ,QAAQ,EAAET,KAAK,CAACkB,SAAS,EAAE,KAAK,CAAC,CAACG,IAAI,CAAC,CAAC;EAE5ErB,KAAK,CAACsB,IAAI,GAAGb,QAAQ;EAErBF,KAAK,GAAYP,KAAK,CAACuB,IAAI,CAAC,gBAAgB,EAAE,GAAG,EAAE,CAAC,CAAC;EACrDhB,KAAK,CAACiB,GAAG,GAAQ,CAAEvB,SAAS,EAAED,KAAK,CAACsB,IAAI,CAAE;EAE1Cf,KAAK,GAAYP,KAAK,CAACuB,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;EAC5ChB,KAAK,CAACJ,OAAO,GAAIA,OAAO;EACxBI,KAAK,CAACiB,GAAG,GAAQ,CAAEvB,SAAS,EAAED,KAAK,CAACsB,IAAI,CAAE;EAC1Cf,KAAK,CAACkB,QAAQ,GAAG,EAAE;EAEnBlB,KAAK,GAAYP,KAAK,CAACuB,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;EAEvDvB,KAAK,CAACe,UAAU,GAAGP,aAAa;EAEhC,OAAO,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}