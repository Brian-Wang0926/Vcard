{"ast":null,"code":"/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \n * dictionaries.\n */\n\nvar Typo;\n(function () {\n  \"use strict\";\n\n  /**\n   * Typo constructor.\n   *\n   * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\n   *                              \"en_US\". This is only used to auto-load dictionaries.\n   * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .aff\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n   * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\n   *                              and Typo.js is being used in a Chrome extension, the .dic\n   *                              file will be loaded automatically from\n   *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n   *                              In other environments, it will be loaded from\n   *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n   * @param {Object} [settings]   Constructor settings. Available properties are:\n   *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\n   *                              environment.\n   *                              {Object} [flags]: flag information.\n   *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n   *                              asynchronously.\n   *                              {Function} [loadedCallback]: Called when both affData and wordsData\n   *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n   *                              is the instantiated Typo object.\n   *\n   * @returns {Typo} A Typo object.\n   */\n  Typo = function (dictionary, affData, wordsData, settings) {\n    settings = settings || {};\n    this.dictionary = null;\n    this.rules = {};\n    this.dictionaryTable = {};\n    this.compoundRules = [];\n    this.compoundRuleCodes = {};\n    this.replacementTable = [];\n    this.flags = settings.flags || {};\n    this.memoized = {};\n    this.loaded = false;\n    var self = this;\n    var path;\n\n    // Loop-control variables.\n    var i, j, _len, _jlen;\n    if (dictionary) {\n      self.dictionary = dictionary;\n\n      // If the data is preloaded, just setup the Typo object.\n      if (affData && wordsData) {\n        setup();\n      }\n      // Loading data for Chrome extentions.\n      else if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\n        if (settings.dictionaryPath) {\n          path = settings.dictionaryPath;\n        } else {\n          path = \"typo/dictionaries\";\n        }\n        if (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n        if (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n      } else {\n        if (settings.dictionaryPath) {\n          path = settings.dictionaryPath;\n        } else if (typeof __dirname !== 'undefined') {\n          path = __dirname + '/dictionaries';\n        } else {\n          path = './dictionaries';\n        }\n        if (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n        if (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n      }\n    }\n    function readDataFile(url, setFunc) {\n      var response = self._readFile(url, null, settings.asyncLoad);\n      if (settings.asyncLoad) {\n        response.then(function (data) {\n          setFunc(data);\n        });\n      } else {\n        setFunc(response);\n      }\n    }\n    function setAffData(data) {\n      affData = data;\n      if (wordsData) {\n        setup();\n      }\n    }\n    function setWordsData(data) {\n      wordsData = data;\n      if (affData) {\n        setup();\n      }\n    }\n    function setup() {\n      self.rules = self._parseAFF(affData);\n\n      // Save the rule codes that are used in compound rules.\n      self.compoundRuleCodes = {};\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var rule = self.compoundRules[i];\n        for (j = 0, _jlen = rule.length; j < _jlen; j++) {\n          self.compoundRuleCodes[rule[j]] = [];\n        }\n      }\n\n      // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n      // will do the work of saving the list of words that are compound-only.\n      if (\"ONLYINCOMPOUND\" in self.flags) {\n        self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n      }\n      self.dictionaryTable = self._parseDIC(wordsData);\n\n      // Get rid of any codes from the compound rule codes that are never used \n      // (or that were special regex characters).  Not especially necessary... \n      for (i in self.compoundRuleCodes) {\n        if (self.compoundRuleCodes[i].length === 0) {\n          delete self.compoundRuleCodes[i];\n        }\n      }\n\n      // Build the full regular expressions for each compound rule.\n      // I have a feeling (but no confirmation yet) that this method of \n      // testing for compound words is probably slow.\n      for (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n        var ruleText = self.compoundRules[i];\n        var expressionText = \"\";\n        for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n          var character = ruleText[j];\n          if (character in self.compoundRuleCodes) {\n            expressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n          } else {\n            expressionText += character;\n          }\n        }\n        self.compoundRules[i] = new RegExp(expressionText, \"i\");\n      }\n      self.loaded = true;\n      if (settings.asyncLoad && settings.loadedCallback) {\n        settings.loadedCallback(self);\n      }\n    }\n    return this;\n  };\n  Typo.prototype = {\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n\n    load: function (obj) {\n      for (var i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          this[i] = obj[i];\n        }\n      }\n      return this;\n    },\n    /**\n     * Read the contents of a file.\n     * \n     * @param {String} path The path (relative) to the file.\n     * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     *        files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     *          always returned.\n     */\n\n    _readFile: function (path, charset, async) {\n      charset = charset || \"utf8\";\n      if (typeof XMLHttpRequest !== 'undefined') {\n        var promise;\n        var req = new XMLHttpRequest();\n        req.open(\"GET\", path, async);\n        if (async) {\n          promise = new Promise(function (resolve, reject) {\n            req.onload = function () {\n              if (req.status === 200) {\n                resolve(req.responseText);\n              } else {\n                reject(req.statusText);\n              }\n            };\n            req.onerror = function () {\n              reject(req.statusText);\n            };\n          });\n        }\n        if (req.overrideMimeType) req.overrideMimeType(\"text/plain; charset=\" + charset);\n        req.send(null);\n        return async ? promise : req.responseText;\n      } else if (typeof require !== 'undefined') {\n        // Node.js\n        var fs = require(\"fs\");\n        try {\n          if (fs.existsSync(path)) {\n            return fs.readFileSync(path, charset);\n          } else {\n            console.log(\"Path \" + path + \" does not exist.\");\n          }\n        } catch (e) {\n          console.log(e);\n          return '';\n        }\n      }\n    },\n    /**\n     * Parse the rules out from a .aff file.\n     *\n     * @param {String} data The contents of the affix file.\n     * @returns object The rules from the file.\n     */\n\n    _parseAFF: function (data) {\n      var rules = {};\n      var line, subline, numEntries, lineParts;\n      var i, j, _len, _jlen;\n      var lines = data.split(/\\r?\\n/);\n      for (i = 0, _len = lines.length; i < _len; i++) {\n        // Remove comment lines\n        line = this._removeAffixComments(lines[i]);\n        line = line.trim();\n        if (!line) {\n          continue;\n        }\n        var definitionParts = line.split(/\\s+/);\n        var ruleType = definitionParts[0];\n        if (ruleType == \"PFX\" || ruleType == \"SFX\") {\n          var ruleCode = definitionParts[1];\n          var combineable = definitionParts[2];\n          numEntries = parseInt(definitionParts[3], 10);\n          var entries = [];\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            subline = lines[j];\n            lineParts = subline.split(/\\s+/);\n            var charactersToRemove = lineParts[2];\n            var additionParts = lineParts[3].split(\"/\");\n            var charactersToAdd = additionParts[0];\n            if (charactersToAdd === \"0\") charactersToAdd = \"\";\n            var continuationClasses = this.parseRuleCodes(additionParts[1]);\n            var regexToMatch = lineParts[4];\n            var entry = {};\n            entry.add = charactersToAdd;\n            if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n            if (regexToMatch !== \".\") {\n              if (ruleType === \"SFX\") {\n                entry.match = new RegExp(regexToMatch + \"$\");\n              } else {\n                entry.match = new RegExp(\"^\" + regexToMatch);\n              }\n            }\n            if (charactersToRemove != \"0\") {\n              if (ruleType === \"SFX\") {\n                entry.remove = new RegExp(charactersToRemove + \"$\");\n              } else {\n                entry.remove = charactersToRemove;\n              }\n            }\n            entries.push(entry);\n          }\n          rules[ruleCode] = {\n            \"type\": ruleType,\n            \"combineable\": combineable == \"Y\",\n            \"entries\": entries\n          };\n          i += numEntries;\n        } else if (ruleType === \"COMPOUNDRULE\") {\n          numEntries = parseInt(definitionParts[1], 10);\n          for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n            line = lines[j];\n            lineParts = line.split(/\\s+/);\n            this.compoundRules.push(lineParts[1]);\n          }\n          i += numEntries;\n        } else if (ruleType === \"REP\") {\n          lineParts = line.split(/\\s+/);\n          if (lineParts.length === 3) {\n            this.replacementTable.push([lineParts[1], lineParts[2]]);\n          }\n        } else {\n          // ONLYINCOMPOUND\n          // COMPOUNDMIN\n          // FLAG\n          // KEEPCASE\n          // NEEDAFFIX\n\n          this.flags[ruleType] = definitionParts[1];\n        }\n      }\n      return rules;\n    },\n    /**\n     * Removes comments.\n     *\n     * @param {String} data A line from an affix file.\n     * @return {String} The cleaned-up line.\n     */\n\n    _removeAffixComments: function (line) {\n      // This used to remove any string starting with '#' up to the end of the line,\n      // but some COMPOUNDRULE definitions include '#' as part of the rule.\n      // So, only remove lines that begin with a comment, optionally preceded by whitespace.\n      if (line.match(/^\\s*#/, \"\")) {\n        return '';\n      }\n      return line;\n    },\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n     */\n\n    _parseDIC: function (data) {\n      data = this._removeDicComments(data);\n      var lines = data.split(/\\r?\\n/);\n      var dictionaryTable = {};\n      function addWord(word, rules) {\n        // Some dictionaries will list the same word multiple times with different rule sets.\n        if (!dictionaryTable.hasOwnProperty(word)) {\n          dictionaryTable[word] = null;\n        }\n        if (rules.length > 0) {\n          if (dictionaryTable[word] === null) {\n            dictionaryTable[word] = [];\n          }\n          dictionaryTable[word].push(rules);\n        }\n      }\n\n      // The first line is the number of words in the dictionary.\n      for (var i = 1, _len = lines.length; i < _len; i++) {\n        var line = lines[i];\n        if (!line) {\n          // Ignore empty lines.\n          continue;\n        }\n        var parts = line.split(\"/\", 2);\n        var word = parts[0];\n\n        // Now for each affix rule, generate that form of the word.\n        if (parts.length > 1) {\n          var ruleCodesArray = this.parseRuleCodes(parts[1]);\n\n          // Save the ruleCodes for compound word situations.\n          if (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\n            addWord(word, ruleCodesArray);\n          }\n          for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n            var code = ruleCodesArray[j];\n            var rule = this.rules[code];\n            if (rule) {\n              var newWords = this._applyRule(word, rule);\n              for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n                var newWord = newWords[ii];\n                addWord(newWord, []);\n                if (rule.combineable) {\n                  for (var k = j + 1; k < _jlen; k++) {\n                    var combineCode = ruleCodesArray[k];\n                    var combineRule = this.rules[combineCode];\n                    if (combineRule) {\n                      if (combineRule.combineable && rule.type != combineRule.type) {\n                        var otherNewWords = this._applyRule(newWord, combineRule);\n                        for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n                          var otherNewWord = otherNewWords[iii];\n                          addWord(otherNewWord, []);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            if (code in this.compoundRuleCodes) {\n              this.compoundRuleCodes[code].push(word);\n            }\n          }\n        } else {\n          addWord(word.trim(), []);\n        }\n      }\n      return dictionaryTable;\n    },\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n\n    _removeDicComments: function (data) {\n      // I can't find any official documentation on it, but at least the de_DE\n      // dictionary uses tab-indented lines as comments.\n\n      // Remove comments\n      data = data.replace(/^\\t.*$/mg, \"\");\n      return data;\n    },\n    parseRuleCodes: function (textCodes) {\n      if (!textCodes) {\n        return [];\n      } else if (!(\"FLAG\" in this.flags)) {\n        // The flag symbols are single characters\n        return textCodes.split(\"\");\n      } else if (this.flags.FLAG === \"long\") {\n        // The flag symbols are two characters long.\n        var flags = [];\n        for (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n          flags.push(textCodes.substr(i, 2));\n        }\n        return flags;\n      } else if (this.flags.FLAG === \"num\") {\n        // The flag symbols are a CSV list of numbers.\n        return textCodes.split(\",\");\n      } else if (this.flags.FLAG === \"UTF-8\") {\n        // The flags are single UTF-8 characters.\n        // @see https://github.com/cfinke/Typo.js/issues/57\n        return Array.from(textCodes);\n      } else {\n        // It's possible that this fallback case will not work for all FLAG values,\n        // but I think it's more likely to work than not returning anything at all.\n        return textCodes.split(\"\");\n      }\n    },\n    /**\n     * Applies an affix rule to a word.\n     *\n     * @param {String} word The base word.\n     * @param {Object} rule The affix rule.\n     * @returns {String[]} The new words generated by the rule.\n     */\n\n    _applyRule: function (word, rule) {\n      var entries = rule.entries;\n      var newWords = [];\n      for (var i = 0, _len = entries.length; i < _len; i++) {\n        var entry = entries[i];\n        if (!entry.match || word.match(entry.match)) {\n          var newWord = word;\n          if (entry.remove) {\n            newWord = newWord.replace(entry.remove, \"\");\n          }\n          if (rule.type === \"SFX\") {\n            newWord = newWord + entry.add;\n          } else {\n            newWord = entry.add + newWord;\n          }\n          newWords.push(newWord);\n          if (\"continuationClasses\" in entry) {\n            for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n              var continuationRule = this.rules[entry.continuationClasses[j]];\n              if (continuationRule) {\n                newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n              }\n              /*\n              else {\n              \t// This shouldn't happen, but it does, at least in the de_DE dictionary.\n              \t// I think the author mistakenly supplied lower-case rule codes instead \n              \t// of upper-case.\n              }\n              */\n            }\n          }\n        }\n      }\n\n      return newWords;\n    },\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {String} aWord The word to check.\n     * @returns {Boolean}\n     */\n\n    check: function (aWord) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n\n      // Remove leading and trailing whitespace\n      var trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n      if (this.checkExact(trimmedWord)) {\n        return true;\n      }\n\n      // The exact word is not in the dictionary.\n      if (trimmedWord.toUpperCase() === trimmedWord) {\n        // The word was supplied in all uppercase.\n        // Check for a capitalized form of the word.\n        var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n        if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        }\n        if (this.checkExact(capitalizedWord)) {\n          // The all-caps word is a capitalized word spelled correctly.\n          return true;\n        }\n        if (this.checkExact(trimmedWord.toLowerCase())) {\n          // The all-caps is a lowercase word spelled correctly.\n          return true;\n        }\n      }\n      var uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n      if (uncapitalizedWord !== trimmedWord) {\n        if (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n          // Capitalization variants are not allowed for this word.\n          return false;\n        }\n\n        // Check for an uncapitalized form\n        if (this.checkExact(uncapitalizedWord)) {\n          // The word is spelled correctly but with the first letter capitalized.\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Checks whether a word exists in the current dictionary.\n     *\n     * @param {String} word The word to check.\n     * @returns {Boolean}\n     */\n\n    checkExact: function (word) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      var ruleCodes = this.dictionaryTable[word];\n      var i, _len;\n      if (typeof ruleCodes === 'undefined') {\n        // Check if this might be a compound word.\n        if (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n          for (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n            if (word.match(this.compoundRules[i])) {\n              return true;\n            }\n          }\n        }\n      } else if (ruleCodes === null) {\n        // a null (but not undefined) value for an entry in the dictionary table\n        // means that the word is in the dictionary but has no flags.\n        return true;\n      } else if (typeof ruleCodes === 'object') {\n        // this.dictionary['hasOwnProperty'] will be a function.\n        for (i = 0, _len = ruleCodes.length; i < _len; i++) {\n          if (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {String} word The word in question.\n     * @param {String} flag The flag in question.\n     * @return {Boolean}\n     */\n\n    hasFlag: function (word, flag, wordFlags) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      if (flag in this.flags) {\n        if (typeof wordFlags === 'undefined') {\n          wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n        }\n        if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Returns a list of suggestions for a misspelled word.\n     *\n     * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n     * This suggestor is primitive, but it works.\n     *\n     * @param {String} word The misspelling.\n     * @param {Number} [limit=5] The maximum number of suggestions to return.\n     * @returns {String[]} The array of suggestions.\n     */\n\n    alphabet: \"\",\n    suggest: function (word, limit) {\n      if (!this.loaded) {\n        throw \"Dictionary not loaded.\";\n      }\n      limit = limit || 5;\n      if (this.memoized.hasOwnProperty(word)) {\n        var memoizedLimit = this.memoized[word]['limit'];\n\n        // Only return the cached list if it's big enough or if there weren't enough suggestions\n        // to fill a smaller limit.\n        if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n          return this.memoized[word]['suggestions'].slice(0, limit);\n        }\n      }\n      if (this.check(word)) return [];\n\n      // Check the replacement table.\n      for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n        var replacementEntry = this.replacementTable[i];\n        if (word.indexOf(replacementEntry[0]) !== -1) {\n          var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n          if (this.check(correctedWord)) {\n            return [correctedWord];\n          }\n        }\n      }\n      if (!this.alphabet) {\n        // Use the English alphabet as the default. Problematic, but backwards-compatible.\n        this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n        // Any characters defined in the affix file as substitutions can go in the alphabet too.\n        // Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.\n        // For example, Q is not in the default English TRY list; that's why having the default\n        // alphabet above is useful.\n        if ('TRY' in this.flags) {\n          this.alphabet += this.flags['TRY'];\n        }\n\n        // Plus any additional characters specifically defined as being allowed in words.\n        if ('WORDCHARS' in this.flags) {\n          this.alphabet += this.flags['WORDCHARS'];\n        }\n\n        // Remove any duplicates.\n        var alphaArray = this.alphabet.split(\"\");\n        alphaArray.sort();\n        var alphaHash = {};\n        for (var i = 0; i < alphaArray.length; i++) {\n          alphaHash[alphaArray[i]] = true;\n        }\n        this.alphabet = '';\n        for (var i in alphaHash) {\n          this.alphabet += i;\n        }\n      }\n      var self = this;\n\n      /**\n       * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n       * The value of each entry is the number of unique ways that the resulting word can be made.\n       *\n       * @arg mixed words Either a hash keyed by words or a string word to operate on.\n       * @arg bool known_only Whether this function should ignore strings that are not in the dictionary.\n       */\n      function edits1(words, known_only) {\n        var rv = {};\n        var i, j, _iilen, _len, _jlen, _edit;\n        var alphabetLength = self.alphabet.length;\n        if (typeof words == 'string') {\n          var word = words;\n          words = {};\n          words[word] = true;\n        }\n        for (var word in words) {\n          for (i = 0, _len = word.length + 1; i < _len; i++) {\n            var s = [word.substring(0, i), word.substring(i)];\n\n            // Remove a letter.\n            if (s[1]) {\n              _edit = s[0] + s[1].substring(1);\n              if (!known_only || self.check(_edit)) {\n                if (!(_edit in rv)) {\n                  rv[_edit] = 1;\n                } else {\n                  rv[_edit] += 1;\n                }\n              }\n            }\n\n            // Transpose letters\n            // Eliminate transpositions of identical letters\n            if (s[1].length > 1 && s[1][1] !== s[1][0]) {\n              _edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n              if (!known_only || self.check(_edit)) {\n                if (!(_edit in rv)) {\n                  rv[_edit] = 1;\n                } else {\n                  rv[_edit] += 1;\n                }\n              }\n            }\n            if (s[1]) {\n              // Replace a letter with another letter.\n\n              var lettercase = s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? 'uppercase' : 'lowercase';\n              for (j = 0; j < alphabetLength; j++) {\n                var replacementLetter = self.alphabet[j];\n\n                // Set the case of the replacement letter to the same as the letter being replaced.\n                if ('uppercase' === lettercase) {\n                  replacementLetter = replacementLetter.toUpperCase();\n                }\n\n                // Eliminate replacement of a letter by itself\n                if (replacementLetter != s[1].substring(0, 1)) {\n                  _edit = s[0] + replacementLetter + s[1].substring(1);\n                  if (!known_only || self.check(_edit)) {\n                    if (!(_edit in rv)) {\n                      rv[_edit] = 1;\n                    } else {\n                      rv[_edit] += 1;\n                    }\n                  }\n                }\n              }\n            }\n            if (s[1]) {\n              // Add a letter between each letter.\n              for (j = 0; j < alphabetLength; j++) {\n                // If the letters on each side are capitalized, capitalize the replacement.\n                var lettercase = s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0, 1).toUpperCase() === s[1].substring(0, 1) ? 'uppercase' : 'lowercase';\n                var replacementLetter = self.alphabet[j];\n                if ('uppercase' === lettercase) {\n                  replacementLetter = replacementLetter.toUpperCase();\n                }\n                _edit = s[0] + replacementLetter + s[1];\n                if (!known_only || self.check(_edit)) {\n                  if (!(_edit in rv)) {\n                    rv[_edit] = 1;\n                  } else {\n                    rv[_edit] += 1;\n                  }\n                }\n              }\n            }\n          }\n        }\n        return rv;\n      }\n      function correct(word) {\n        // Get the edit-distance-1 and edit-distance-2 forms of this word.\n        var ed1 = edits1(word);\n        var ed2 = edits1(ed1, true);\n\n        // Sort the edits based on how many different ways they were created.\n        var weighted_corrections = ed2;\n        for (var ed1word in ed1) {\n          if (!self.check(ed1word)) {\n            continue;\n          }\n          if (ed1word in weighted_corrections) {\n            weighted_corrections[ed1word] += ed1[ed1word];\n          } else {\n            weighted_corrections[ed1word] = ed1[ed1word];\n          }\n        }\n        var i, _len;\n        var sorted_corrections = [];\n        for (i in weighted_corrections) {\n          if (weighted_corrections.hasOwnProperty(i)) {\n            sorted_corrections.push([i, weighted_corrections[i]]);\n          }\n        }\n        function sorter(a, b) {\n          var a_val = a[1];\n          var b_val = b[1];\n          if (a_val < b_val) {\n            return -1;\n          } else if (a_val > b_val) {\n            return 1;\n          }\n          // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n          return b[0].localeCompare(a[0]);\n        }\n        sorted_corrections.sort(sorter).reverse();\n        var rv = [];\n        var capitalization_scheme = \"lowercase\";\n        if (word.toUpperCase() === word) {\n          capitalization_scheme = \"uppercase\";\n        } else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n          capitalization_scheme = \"capitalized\";\n        }\n        var working_limit = limit;\n        for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n          if (\"uppercase\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n          } else if (\"capitalized\" === capitalization_scheme) {\n            sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n          }\n          if (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) == -1) {\n            rv.push(sorted_corrections[i][0]);\n          } else {\n            // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n            working_limit++;\n          }\n        }\n        return rv;\n      }\n      this.memoized[word] = {\n        'suggestions': correct(word),\n        'limit': limit\n      };\n      return this.memoized[word]['suggestions'];\n    }\n  };\n})();\n\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n  module.exports = Typo;\n}","map":{"version":3,"names":["Typo","dictionary","affData","wordsData","settings","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","flags","memoized","loaded","self","path","i","j","_len","_jlen","setup","window","chrome","extension","dictionaryPath","readDataFile","getURL","setAffData","setWordsData","__dirname","url","setFunc","response","_readFile","asyncLoad","then","data","_parseAFF","length","rule","ONLYINCOMPOUND","_parseDIC","ruleText","expressionText","character","join","RegExp","loadedCallback","prototype","load","obj","hasOwnProperty","charset","async","XMLHttpRequest","promise","req","open","Promise","resolve","reject","onload","status","responseText","statusText","onerror","overrideMimeType","send","require","fs","existsSync","readFileSync","console","log","e","line","subline","numEntries","lineParts","lines","split","_removeAffixComments","trim","definitionParts","ruleType","ruleCode","combineable","parseInt","entries","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","_removeDicComments","addWord","word","parts","ruleCodesArray","indexOf","NEEDAFFIX","code","newWords","_applyRule","ii","_iilen","newWord","k","combineCode","combineRule","type","otherNewWords","iii","_iiilen","otherNewWord","replace","textCodes","FLAG","substr","Array","from","continuationRule","concat","check","aWord","trimmedWord","checkExact","toUpperCase","capitalizedWord","substring","toLowerCase","hasFlag","uncapitalizedWord","ruleCodes","COMPOUNDMIN","flag","wordFlags","apply","alphabet","suggest","limit","memoizedLimit","slice","replacementEntry","correctedWord","alphaArray","sort","alphaHash","edits1","words","known_only","rv","_edit","alphabetLength","s","lettercase","replacementLetter","correct","ed1","ed2","weighted_corrections","ed1word","sorted_corrections","sorter","a","b","a_val","b_val","localeCompare","reverse","capitalization_scheme","working_limit","Math","min","module","exports"],"sources":["/Users/wangbaiyuan/Documents/Wehelp/Part3/Vcard/client/node_modules/typo-js/typo.js"],"sourcesContent":["/* globals chrome: false */\n/* globals __dirname: false */\n/* globals require: false */\n/* globals Buffer: false */\n/* globals module: false */\n\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style \n * dictionaries.\n */\n\nvar Typo;\n\n(function () {\n\"use strict\";\n\n/**\n * Typo constructor.\n *\n * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,\n *                              \"en_US\". This is only used to auto-load dictionaries.\n * @param {String} [affData]    The data from the dictionary's .aff file. If omitted\n *                              and Typo.js is being used in a Chrome extension, the .aff\n *                              file will be loaded automatically from\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff\n *                              In other environments, it will be loaded from\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff\n * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted\n *                              and Typo.js is being used in a Chrome extension, the .dic\n *                              file will be loaded automatically from\n *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic\n *                              In other environments, it will be loaded from\n *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic\n * @param {Object} [settings]   Constructor settings. Available properties are:\n *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome\n *                              environment.\n *                              {Object} [flags]: flag information.\n *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded\n *                              asynchronously.\n *                              {Function} [loadedCallback]: Called when both affData and wordsData\n *                              have been loaded. Only used if asyncLoad is set to true. The parameter\n *                              is the instantiated Typo object.\n *\n * @returns {Typo} A Typo object.\n */\n\nTypo = function (dictionary, affData, wordsData, settings) {\n\tsettings = settings || {};\n\n\tthis.dictionary = null;\n\t\n\tthis.rules = {};\n\tthis.dictionaryTable = {};\n\t\n\tthis.compoundRules = [];\n\tthis.compoundRuleCodes = {};\n\t\n\tthis.replacementTable = [];\n\t\n\tthis.flags = settings.flags || {}; \n\t\n\tthis.memoized = {};\n\n\tthis.loaded = false;\n\t\n\tvar self = this;\n\t\n\tvar path;\n\t\n\t// Loop-control variables.\n\tvar i, j, _len, _jlen;\n\t\n\tif (dictionary) {\n\t\tself.dictionary = dictionary;\n\t\t\n\t\t// If the data is preloaded, just setup the Typo object.\n\t\tif (affData && wordsData) {\n\t\t\tsetup();\n\t\t}\n\t\t// Loading data for Chrome extentions.\n\t\telse if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {\n\t\t\tif (settings.dictionaryPath) {\n\t\t\t\tpath = settings.dictionaryPath;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = \"typo/dictionaries\";\n\t\t\t}\n\t\t\t\n\t\t\tif (!affData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\"), setAffData);\n\t\t\tif (!wordsData) readDataFile(chrome.extension.getURL(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\"), setWordsData);\n\t\t}\n\t\telse {\n\t\t\tif (settings.dictionaryPath) {\n\t\t\t\tpath = settings.dictionaryPath;\n\t\t\t}\n\t\t\telse if (typeof __dirname !== 'undefined') {\n\t\t\t\tpath = __dirname + '/dictionaries';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpath = './dictionaries';\n\t\t\t}\n\t\t\t\n\t\t\tif (!affData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".aff\", setAffData);\n\t\t\tif (!wordsData) readDataFile(path + \"/\" + dictionary + \"/\" + dictionary + \".dic\", setWordsData);\n\t\t}\n\t}\n\t\n\tfunction readDataFile(url, setFunc) {\n\t\tvar response = self._readFile(url, null, settings.asyncLoad);\n\t\t\n\t\tif (settings.asyncLoad) {\n\t\t\tresponse.then(function(data) {\n\t\t\t\tsetFunc(data);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tsetFunc(response);\n\t\t}\n\t}\n\n\tfunction setAffData(data) {\n\t\taffData = data;\n\n\t\tif (wordsData) {\n\t\t\tsetup();\n\t\t}\n\t}\n\n\tfunction setWordsData(data) {\n\t\twordsData = data;\n\n\t\tif (affData) {\n\t\t\tsetup();\n\t\t}\n\t}\n\n\tfunction setup() {\n\t\tself.rules = self._parseAFF(affData);\n\t\t\n\t\t// Save the rule codes that are used in compound rules.\n\t\tself.compoundRuleCodes = {};\n\t\t\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n\t\t\tvar rule = self.compoundRules[i];\n\t\t\t\n\t\t\tfor (j = 0, _jlen = rule.length; j < _jlen; j++) {\n\t\t\t\tself.compoundRuleCodes[rule[j]] = [];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n\t\t// will do the work of saving the list of words that are compound-only.\n\t\tif (\"ONLYINCOMPOUND\" in self.flags) {\n\t\t\tself.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];\n\t\t}\n\t\t\n\t\tself.dictionaryTable = self._parseDIC(wordsData);\n\t\t\n\t\t// Get rid of any codes from the compound rule codes that are never used \n\t\t// (or that were special regex characters).  Not especially necessary... \n\t\tfor (i in self.compoundRuleCodes) {\n\t\t\tif (self.compoundRuleCodes[i].length === 0) {\n\t\t\t\tdelete self.compoundRuleCodes[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Build the full regular expressions for each compound rule.\n\t\t// I have a feeling (but no confirmation yet) that this method of \n\t\t// testing for compound words is probably slow.\n\t\tfor (i = 0, _len = self.compoundRules.length; i < _len; i++) {\n\t\t\tvar ruleText = self.compoundRules[i];\n\t\t\t\n\t\t\tvar expressionText = \"\";\n\t\t\t\n\t\t\tfor (j = 0, _jlen = ruleText.length; j < _jlen; j++) {\n\t\t\t\tvar character = ruleText[j];\n\t\t\t\t\n\t\t\t\tif (character in self.compoundRuleCodes) {\n\t\t\t\t\texpressionText += \"(\" + self.compoundRuleCodes[character].join(\"|\") + \")\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texpressionText += character;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tself.compoundRules[i] = new RegExp(expressionText, \"i\");\n\t\t}\n\t\t\n\t\tself.loaded = true;\n\t\t\n\t\tif (settings.asyncLoad && settings.loadedCallback) {\n\t\t\tsettings.loadedCallback(self);\n\t\t}\n\t}\n\t\n\treturn this;\n};\n\nTypo.prototype = {\n\t/**\n\t * Loads a Typo instance from a hash of all of the Typo properties.\n\t *\n\t * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n\t */\n\t\n\tload : function (obj) {\n\t\tfor (var i in obj) {\n\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\tthis[i] = obj[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn this;\n\t},\n\t\n\t/**\n\t * Read the contents of a file.\n\t * \n\t * @param {String} path The path (relative) to the file.\n\t * @param {String} [charset=\"ISO8859-1\"] The expected charset of the file\n\t * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n\t *        files are read synchronously.\n\t * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n\t *          always returned.\n\t */\n\t\n\t_readFile : function (path, charset, async) {\n\t\tcharset = charset || \"utf8\";\n\t\t\n\t\tif (typeof XMLHttpRequest !== 'undefined') {\n\t\t\tvar promise;\n\t\t\tvar req = new XMLHttpRequest();\n\t\t\treq.open(\"GET\", path, async);\n\t\t\t\n\t\t\tif (async) {\n\t\t\t\tpromise = new Promise(function(resolve, reject) {\n\t\t\t\t\treq.onload = function() {\n\t\t\t\t\t\tif (req.status === 200) {\n\t\t\t\t\t\t\tresolve(req.responseText);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treject(req.statusText);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\treq.onerror = function() {\n\t\t\t\t\t\treject(req.statusText);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\n\t\t\tif (req.overrideMimeType)\n\t\t\t\treq.overrideMimeType(\"text/plain; charset=\" + charset);\n\t\t\n\t\t\treq.send(null);\n\t\t\t\n\t\t\treturn async ? promise : req.responseText;\n\t\t}\n\t\telse if (typeof require !== 'undefined') {\n\t\t\t// Node.js\n\t\t\tvar fs = require(\"fs\");\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif (fs.existsSync(path)) {\n\t\t\t\t\treturn fs.readFileSync(path, charset);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.log(\"Path \" + path + \" does not exist.\");\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.log(e);\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t},\n\t\n\t/**\n\t * Parse the rules out from a .aff file.\n\t *\n\t * @param {String} data The contents of the affix file.\n\t * @returns object The rules from the file.\n\t */\n\t\n\t_parseAFF : function (data) {\n\t\tvar rules = {};\n\t\t\n\t\tvar line, subline, numEntries, lineParts;\n\t\tvar i, j, _len, _jlen;\n\t\t\n\t\tvar lines = data.split(/\\r?\\n/);\n\t\t\n\t\tfor (i = 0, _len = lines.length; i < _len; i++) {\n\t\t\t// Remove comment lines\n\t\t\tline = this._removeAffixComments(lines[i]);\n\t\t\tline = line.trim();\n\t\t\t\n\t\t\tif ( ! line ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvar definitionParts = line.split(/\\s+/);\n\t\t\t\n\t\t\tvar ruleType = definitionParts[0];\n\t\t\t\n\t\t\tif (ruleType == \"PFX\" || ruleType == \"SFX\") {\n\t\t\t\tvar ruleCode = definitionParts[1];\n\t\t\t\tvar combineable = definitionParts[2];\n\t\t\t\tnumEntries = parseInt(definitionParts[3], 10);\n\t\t\t\t\n\t\t\t\tvar entries = [];\n\t\t\t\t\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n\t\t\t\t\tsubline = lines[j];\n\t\t\t\t\t\n\t\t\t\t\tlineParts = subline.split(/\\s+/);\n\t\t\t\t\tvar charactersToRemove = lineParts[2];\n\t\t\t\t\t\n\t\t\t\t\tvar additionParts = lineParts[3].split(\"/\");\n\t\t\t\t\t\n\t\t\t\t\tvar charactersToAdd = additionParts[0];\n\t\t\t\t\tif (charactersToAdd === \"0\") charactersToAdd = \"\";\n\t\t\t\t\t\n\t\t\t\t\tvar continuationClasses = this.parseRuleCodes(additionParts[1]);\n\t\t\t\t\t\n\t\t\t\t\tvar regexToMatch = lineParts[4];\n\t\t\t\t\t\n\t\t\t\t\tvar entry = {};\n\t\t\t\t\tentry.add = charactersToAdd;\n\t\t\t\t\t\n\t\t\t\t\tif (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;\n\t\t\t\t\t\n\t\t\t\t\tif (regexToMatch !== \".\") {\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\n\t\t\t\t\t\t\tentry.match = new RegExp(regexToMatch + \"$\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tentry.match = new RegExp(\"^\" + regexToMatch);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (charactersToRemove != \"0\") {\n\t\t\t\t\t\tif (ruleType === \"SFX\") {\n\t\t\t\t\t\t\tentry.remove = new RegExp(charactersToRemove  + \"$\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tentry.remove = charactersToRemove;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trules[ruleCode] = { \"type\" : ruleType, \"combineable\" : (combineable == \"Y\"), \"entries\" : entries };\n\t\t\t\t\n\t\t\t\ti += numEntries;\n\t\t\t}\n\t\t\telse if (ruleType === \"COMPOUNDRULE\") {\n\t\t\t\tnumEntries = parseInt(definitionParts[1], 10);\n\t\t\t\t\n\t\t\t\tfor (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {\n\t\t\t\t\tline = lines[j];\n\t\t\t\t\t\n\t\t\t\t\tlineParts = line.split(/\\s+/);\n\t\t\t\t\tthis.compoundRules.push(lineParts[1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti += numEntries;\n\t\t\t}\n\t\t\telse if (ruleType === \"REP\") {\n\t\t\t\tlineParts = line.split(/\\s+/);\n\t\t\t\t\n\t\t\t\tif (lineParts.length === 3) {\n\t\t\t\t\tthis.replacementTable.push([ lineParts[1], lineParts[2] ]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// ONLYINCOMPOUND\n\t\t\t\t// COMPOUNDMIN\n\t\t\t\t// FLAG\n\t\t\t\t// KEEPCASE\n\t\t\t\t// NEEDAFFIX\n\t\t\t\t\n\t\t\t\tthis.flags[ruleType] = definitionParts[1];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn rules;\n\t},\n\t\n\t/**\n\t * Removes comments.\n\t *\n\t * @param {String} data A line from an affix file.\n\t * @return {String} The cleaned-up line.\n\t */\n\t\n\t_removeAffixComments : function (line) {\n\t\t// This used to remove any string starting with '#' up to the end of the line,\n\t\t// but some COMPOUNDRULE definitions include '#' as part of the rule.\n\t\t// So, only remove lines that begin with a comment, optionally preceded by whitespace.\n\t\tif ( line.match( /^\\s*#/, \"\" ) ) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\treturn line;\n\t},\n\t\n\t/**\n\t * Parses the words out from the .dic file.\n\t *\n\t * @param {String} data The data from the dictionary file.\n\t * @returns object The lookup table containing all of the words and\n\t *                 word forms from the dictionary.\n\t */\n\t\n\t_parseDIC : function (data) {\n\t\tdata = this._removeDicComments(data);\n\t\t\n\t\tvar lines = data.split(/\\r?\\n/);\n\t\tvar dictionaryTable = {};\n\t\t\n\t\tfunction addWord(word, rules) {\n\t\t\t// Some dictionaries will list the same word multiple times with different rule sets.\n\t\t\tif (!dictionaryTable.hasOwnProperty(word)) {\n\t\t\t\tdictionaryTable[word] = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (rules.length > 0) {\n\t\t\t\tif (dictionaryTable[word] === null) {\n\t\t\t\t\tdictionaryTable[word] = [];\n\t\t\t\t}\n\n\t\t\t\tdictionaryTable[word].push(rules);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// The first line is the number of words in the dictionary.\n\t\tfor (var i = 1, _len = lines.length; i < _len; i++) {\n\t\t\tvar line = lines[i];\n\t\t\t\n\t\t\tif (!line) {\n\t\t\t\t// Ignore empty lines.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar parts = line.split(\"/\", 2);\n\t\t\t\n\t\t\tvar word = parts[0];\n\n\t\t\t// Now for each affix rule, generate that form of the word.\n\t\t\tif (parts.length > 1) {\n\t\t\t\tvar ruleCodesArray = this.parseRuleCodes(parts[1]);\n\t\t\t\t\n\t\t\t\t// Save the ruleCodes for compound word situations.\n\t\t\t\tif (!(\"NEEDAFFIX\" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {\n\t\t\t\t\taddWord(word, ruleCodesArray);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {\n\t\t\t\t\tvar code = ruleCodesArray[j];\n\t\t\t\t\t\n\t\t\t\t\tvar rule = this.rules[code];\n\t\t\t\t\t\n\t\t\t\t\tif (rule) {\n\t\t\t\t\t\tvar newWords = this._applyRule(word, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {\n\t\t\t\t\t\t\tvar newWord = newWords[ii];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddWord(newWord, []);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (rule.combineable) {\n\t\t\t\t\t\t\t\tfor (var k = j + 1; k < _jlen; k++) {\n\t\t\t\t\t\t\t\t\tvar combineCode = ruleCodesArray[k];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvar combineRule = this.rules[combineCode];\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (combineRule) {\n\t\t\t\t\t\t\t\t\t\tif (combineRule.combineable && (rule.type != combineRule.type)) {\n\t\t\t\t\t\t\t\t\t\t\tvar otherNewWords = this._applyRule(newWord, combineRule);\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\tfor (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar otherNewWord = otherNewWords[iii];\n\t\t\t\t\t\t\t\t\t\t\t\taddWord(otherNewWord, []);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (code in this.compoundRuleCodes) {\n\t\t\t\t\t\tthis.compoundRuleCodes[code].push(word);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddWord(word.trim(), []);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dictionaryTable;\n\t},\n\t\n\t\n\t/**\n\t * Removes comment lines and then cleans up blank lines and trailing whitespace.\n\t *\n\t * @param {String} data The data from a .dic file.\n\t * @return {String} The cleaned-up data.\n\t */\n\t\n\t_removeDicComments : function (data) {\n\t\t// I can't find any official documentation on it, but at least the de_DE\n\t\t// dictionary uses tab-indented lines as comments.\n\t\t\n\t\t// Remove comments\n\t\tdata = data.replace(/^\\t.*$/mg, \"\");\n\t\t\n\t\treturn data;\n\t},\n\t\n\tparseRuleCodes : function (textCodes) {\n\t\tif (!textCodes) {\n\t\t\treturn [];\n\t\t}\n\t\telse if (!(\"FLAG\" in this.flags)) {\n\t\t\t// The flag symbols are single characters\n\t\t\treturn textCodes.split(\"\");\n\t\t}\n\t\telse if (this.flags.FLAG === \"long\") {\n\t\t\t// The flag symbols are two characters long.\n\t\t\tvar flags = [];\n\t\t\t\n\t\t\tfor (var i = 0, _len = textCodes.length; i < _len; i += 2) {\n\t\t\t\tflags.push(textCodes.substr(i, 2));\n\t\t\t}\n\t\t\t\n\t\t\treturn flags;\n\t\t}\n\t\telse if (this.flags.FLAG === \"num\") {\n\t\t\t// The flag symbols are a CSV list of numbers.\n\t\t\treturn textCodes.split(\",\");\n\t\t}\n\t\telse if (this.flags.FLAG === \"UTF-8\") {\n\t\t\t// The flags are single UTF-8 characters.\n\t\t\t// @see https://github.com/cfinke/Typo.js/issues/57\n\t\t\treturn Array.from(textCodes);\n\t\t}\n\t\telse {\n\t\t\t// It's possible that this fallback case will not work for all FLAG values,\n\t\t\t// but I think it's more likely to work than not returning anything at all.\n\t\t\treturn textCodes.split(\"\");\n\t\t}\n\t},\n\t\n\t/**\n\t * Applies an affix rule to a word.\n\t *\n\t * @param {String} word The base word.\n\t * @param {Object} rule The affix rule.\n\t * @returns {String[]} The new words generated by the rule.\n\t */\n\t\n\t_applyRule : function (word, rule) {\n\t\tvar entries = rule.entries;\n\t\tvar newWords = [];\n\t\t\n\t\tfor (var i = 0, _len = entries.length; i < _len; i++) {\n\t\t\tvar entry = entries[i];\n\t\t\t\n\t\t\tif (!entry.match || word.match(entry.match)) {\n\t\t\t\tvar newWord = word;\n\t\t\t\t\n\t\t\t\tif (entry.remove) {\n\t\t\t\t\tnewWord = newWord.replace(entry.remove, \"\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (rule.type === \"SFX\") {\n\t\t\t\t\tnewWord = newWord + entry.add;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnewWord = entry.add + newWord;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnewWords.push(newWord);\n\t\t\t\t\n\t\t\t\tif (\"continuationClasses\" in entry) {\n\t\t\t\t\tfor (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {\n\t\t\t\t\t\tvar continuationRule = this.rules[entry.continuationClasses[j]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (continuationRule) {\n\t\t\t\t\t\t\tnewWords = newWords.concat(this._applyRule(newWord, continuationRule));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// This shouldn't happen, but it does, at least in the de_DE dictionary.\n\t\t\t\t\t\t\t// I think the author mistakenly supplied lower-case rule codes instead \n\t\t\t\t\t\t\t// of upper-case.\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn newWords;\n\t},\n\t\n\t/**\n\t * Checks whether a word or a capitalization variant exists in the current dictionary.\n\t * The word is trimmed and several variations of capitalizations are checked.\n\t * If you want to check a word without any changes made to it, call checkExact()\n\t *\n\t * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n\t *\n\t * @param {String} aWord The word to check.\n\t * @returns {Boolean}\n\t */\n\t\n\tcheck : function (aWord) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\t\t\n\t\t// Remove leading and trailing whitespace\n\t\tvar trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t\n\t\tif (this.checkExact(trimmedWord)) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// The exact word is not in the dictionary.\n\t\tif (trimmedWord.toUpperCase() === trimmedWord) {\n\t\t\t// The word was supplied in all uppercase.\n\t\t\t// Check for a capitalized form of the word.\n\t\t\tvar capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n\t\t\t\n\t\t\tif (this.hasFlag(capitalizedWord, \"KEEPCASE\")) {\n\t\t\t\t// Capitalization variants are not allowed for this word.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.checkExact(capitalizedWord)) {\n\t\t\t\t// The all-caps word is a capitalized word spelled correctly.\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (this.checkExact(trimmedWord.toLowerCase())) {\n\t\t\t\t// The all-caps is a lowercase word spelled correctly.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar uncapitalizedWord = trimmedWord[0].toLowerCase() + trimmedWord.substring(1);\n\t\t\n\t\tif (uncapitalizedWord !== trimmedWord) {\n\t\t\tif (this.hasFlag(uncapitalizedWord, \"KEEPCASE\")) {\n\t\t\t\t// Capitalization variants are not allowed for this word.\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t// Check for an uncapitalized form\n\t\t\tif (this.checkExact(uncapitalizedWord)) {\n\t\t\t\t// The word is spelled correctly but with the first letter capitalized.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Checks whether a word exists in the current dictionary.\n\t *\n\t * @param {String} word The word to check.\n\t * @returns {Boolean}\n\t */\n\t\n\tcheckExact : function (word) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tvar ruleCodes = this.dictionaryTable[word];\n\t\t\n\t\tvar i, _len;\n\t\t\n\t\tif (typeof ruleCodes === 'undefined') {\n\t\t\t// Check if this might be a compound word.\n\t\t\tif (\"COMPOUNDMIN\" in this.flags && word.length >= this.flags.COMPOUNDMIN) {\n\t\t\t\tfor (i = 0, _len = this.compoundRules.length; i < _len; i++) {\n\t\t\t\t\tif (word.match(this.compoundRules[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (ruleCodes === null) {\n\t\t\t// a null (but not undefined) value for an entry in the dictionary table\n\t\t\t// means that the word is in the dictionary but has no flags.\n\t\t\treturn true;\n\t\t}\n\t\telse if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n\t\t\tfor (i = 0, _len = ruleCodes.length; i < _len; i++) {\n\t\t\t\tif (!this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCodes[i])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Looks up whether a given word is flagged with a given flag.\n\t *\n\t * @param {String} word The word in question.\n\t * @param {String} flag The flag in question.\n\t * @return {Boolean}\n\t */\n\t \n\thasFlag : function (word, flag, wordFlags) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tif (flag in this.flags) {\n\t\t\tif (typeof wordFlags === 'undefined') {\n\t\t\t\twordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);\n\t\t\t}\n\t\t\t\n\t\t\tif (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\t/**\n\t * Returns a list of suggestions for a misspelled word.\n\t *\n\t * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n\t * This suggestor is primitive, but it works.\n\t *\n\t * @param {String} word The misspelling.\n\t * @param {Number} [limit=5] The maximum number of suggestions to return.\n\t * @returns {String[]} The array of suggestions.\n\t */\n\t\n\talphabet : \"\",\n\t\n\tsuggest : function (word, limit) {\n\t\tif (!this.loaded) {\n\t\t\tthrow \"Dictionary not loaded.\";\n\t\t}\n\n\t\tlimit = limit || 5;\n\n\t\tif (this.memoized.hasOwnProperty(word)) {\n\t\t\tvar memoizedLimit = this.memoized[word]['limit'];\n\n\t\t\t// Only return the cached list if it's big enough or if there weren't enough suggestions\n\t\t\t// to fill a smaller limit.\n\t\t\tif (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n\t\t\t\treturn this.memoized[word]['suggestions'].slice(0, limit);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (this.check(word)) return [];\n\t\t\n\t\t// Check the replacement table.\n\t\tfor (var i = 0, _len = this.replacementTable.length; i < _len; i++) {\n\t\t\tvar replacementEntry = this.replacementTable[i];\n\t\t\t\n\t\t\tif (word.indexOf(replacementEntry[0]) !== -1) {\n\t\t\t\tvar correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n\t\t\t\t\n\t\t\t\tif (this.check(correctedWord)) {\n\t\t\t\t\treturn [ correctedWord ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!this.alphabet) {\n\t\t\t// Use the English alphabet as the default. Problematic, but backwards-compatible.\n\t\t\tthis.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\t\t\t\n\t\t\t// Any characters defined in the affix file as substitutions can go in the alphabet too.\n\t\t\t// Note that dictionaries do not include the entire alphabet in the TRY flag when it's there.\n\t\t\t// For example, Q is not in the default English TRY list; that's why having the default\n\t\t\t// alphabet above is useful.\n\t\t\tif ( 'TRY' in this.flags ) {\n\t\t\t\tthis.alphabet += this.flags['TRY'];\n\t\t\t}\n\t\t\t\n\t\t\t// Plus any additional characters specifically defined as being allowed in words.\n\t\t\tif ( 'WORDCHARS' in this.flags ) {\n\t\t\t\tthis.alphabet += this.flags['WORDCHARS'];\n\t\t\t}\n\t\t\t\n\t\t\t// Remove any duplicates.\n\t\t\tvar alphaArray = this.alphabet.split(\"\");\n\t\t\talphaArray.sort();\n\n\t\t\tvar alphaHash = {};\n\t\t\tfor ( var i = 0; i < alphaArray.length; i++ ) {\n\t\t\t\talphaHash[ alphaArray[i] ] = true;\n\t\t\t}\n\t\t\t\n\t\t\tthis.alphabet = '';\n\t\t\t\n\t\t\tfor ( var i in alphaHash ) {\n\t\t\t\tthis.alphabet += i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar self = this;\n\n\t\t/**\n\t\t * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`\n\t\t * The value of each entry is the number of unique ways that the resulting word can be made.\n\t\t *\n\t\t * @arg mixed words Either a hash keyed by words or a string word to operate on.\n\t\t * @arg bool known_only Whether this function should ignore strings that are not in the dictionary.\n\t\t */\n\t\tfunction edits1(words, known_only) {\n\t\t\tvar rv = {};\n\t\t\t\n\t\t\tvar i, j, _iilen, _len, _jlen, _edit;\n\n\t\t\tvar alphabetLength = self.alphabet.length;\n\t\t\t\n\t\t\tif (typeof words == 'string') {\n\t\t\t\tvar word = words;\n\t\t\t\twords = {};\n\t\t\t\twords[word] = true;\n\t\t\t}\n\n\t\t\tfor (var word in words) {\n\t\t\t\tfor (i = 0, _len = word.length + 1; i < _len; i++) {\n\t\t\t\t\tvar s = [ word.substring(0, i), word.substring(i) ];\n\t\t\t\t\n\t\t\t\t\t// Remove a letter.\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\t_edit = s[0] + s[1].substring(1);\n\n\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Transpose letters\n\t\t\t\t\t// Eliminate transpositions of identical letters\n\t\t\t\t\tif (s[1].length > 1 && s[1][1] !== s[1][0]) {\n\t\t\t\t\t\t_edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);\n\n\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\t// Replace a letter with another letter.\n\n\t\t\t\t\t\tvar lettercase = (s[1].substring(0,1).toUpperCase() === s[1].substring(0,1)) ? 'uppercase' : 'lowercase';\n\n\t\t\t\t\t\tfor (j = 0; j < alphabetLength; j++) {\n\t\t\t\t\t\t\tvar replacementLetter = self.alphabet[j];\n\n\t\t\t\t\t\t\t// Set the case of the replacement letter to the same as the letter being replaced.\n\t\t\t\t\t\t\tif ( 'uppercase' === lettercase ) {\n\t\t\t\t\t\t\t\treplacementLetter = replacementLetter.toUpperCase();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Eliminate replacement of a letter by itself\n\t\t\t\t\t\t\tif (replacementLetter != s[1].substring(0,1)){\n\t\t\t\t\t\t\t\t_edit = s[0] + replacementLetter + s[1].substring(1);\n\n\t\t\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s[1]) {\n\t\t\t\t\t\t// Add a letter between each letter.\n\t\t\t\t\t\tfor (j = 0; j < alphabetLength; j++) {\n\t\t\t\t\t\t\t// If the letters on each side are capitalized, capitalize the replacement.\n\t\t\t\t\t\t\tvar lettercase = (s[0].substring(-1).toUpperCase() === s[0].substring(-1) && s[1].substring(0,1).toUpperCase() === s[1].substring(0,1)) ? 'uppercase' : 'lowercase';\n\n\t\t\t\t\t\t\tvar replacementLetter = self.alphabet[j];\n\n\t\t\t\t\t\t\tif ( 'uppercase' === lettercase ) {\n\t\t\t\t\t\t\t\treplacementLetter = replacementLetter.toUpperCase();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_edit = s[0] + replacementLetter + s[1];\n\n\t\t\t\t\t\t\tif (!known_only || self.check(_edit)) {\n\t\t\t\t\t\t\t\tif (!(_edit in rv)) {\n\t\t\t\t\t\t\t\t\trv[_edit] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\trv[_edit] += 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn rv;\n\t\t}\n\n\t\tfunction correct(word) {\n\t\t\t// Get the edit-distance-1 and edit-distance-2 forms of this word.\n\t\t\tvar ed1 = edits1(word);\n\t\t\tvar ed2 = edits1(ed1, true);\n\t\t\t\n\t\t\t// Sort the edits based on how many different ways they were created.\n\t\t\tvar weighted_corrections = ed2;\n\t\t\t\n\t\t\tfor (var ed1word in ed1) {\n\t\t\t\tif (!self.check(ed1word)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (ed1word in weighted_corrections) {\n\t\t\t\t\tweighted_corrections[ed1word] += ed1[ed1word];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tweighted_corrections[ed1word] = ed1[ed1word];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar i, _len;\n\n\t\t\tvar sorted_corrections = [];\n\t\t\t\n\t\t\tfor (i in weighted_corrections) {\n\t\t\t\tif (weighted_corrections.hasOwnProperty(i)) {\n\t\t\t\t\tsorted_corrections.push([ i, weighted_corrections[i] ]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction sorter(a, b) {\n\t\t\t\tvar a_val = a[1];\n\t\t\t\tvar b_val = b[1];\n\t\t\t\tif (a_val < b_val) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (a_val > b_val) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\t// @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n\t\t\t\treturn b[0].localeCompare(a[0]);\n\t\t\t}\n\t\t\t\n\t\t\tsorted_corrections.sort(sorter).reverse();\n\n\t\t\tvar rv = [];\n\n\t\t\tvar capitalization_scheme = \"lowercase\";\n\t\t\t\n\t\t\tif (word.toUpperCase() === word) {\n\t\t\t\tcapitalization_scheme = \"uppercase\";\n\t\t\t}\n\t\t\telse if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {\n\t\t\t\tcapitalization_scheme = \"capitalized\";\n\t\t\t}\n\t\t\t\n\t\t\tvar working_limit = limit;\n\n\t\t\tfor (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {\n\t\t\t\tif (\"uppercase\" === capitalization_scheme) {\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();\n\t\t\t\t}\n\t\t\t\telse if (\"capitalized\" === capitalization_scheme) {\n\t\t\t\t\tsorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!self.hasFlag(sorted_corrections[i][0], \"NOSUGGEST\") && rv.indexOf(sorted_corrections[i][0]) == -1) {\n\t\t\t\t\trv.push(sorted_corrections[i][0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n\t\t\t\t\tworking_limit++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rv;\n\t\t}\n\t\t\n\t\tthis.memoized[word] = {\n\t\t\t'suggestions': correct(word),\n\t\t\t'limit': limit\n\t\t};\n\n\t\treturn this.memoized[word]['suggestions'];\n\t}\n};\n})();\n\n// Support for use as a node.js module.\nif (typeof module !== 'undefined') {\n\tmodule.exports = Typo;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}